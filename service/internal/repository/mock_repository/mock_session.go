// Code generated by mockery v2.12.0. DO NOT EDIT.

package mock_repository

import (
	context "context"
	po "simon/mall/service/internal/model/po"

	mock "github.com/stretchr/testify/mock"

	testing "testing"
)

// MockSessionRepo is an autogenerated mock type for the ISessionRepo type
type MockSessionRepo struct {
	mock.Mock
}

type MockSessionRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSessionRepo) EXPECT() *MockSessionRepo_Expecter {
	return &MockSessionRepo_Expecter{mock: &_m.Mock}
}

// CheckSessionExist provides a mock function with given fields: ctx, token
func (_m *MockSessionRepo) CheckSessionExist(ctx context.Context, token string) (bool, error) {
	ret := _m.Called(ctx, token)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSessionRepo_CheckSessionExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckSessionExist'
type MockSessionRepo_CheckSessionExist_Call struct {
	*mock.Call
}

// CheckSessionExist is a helper method to define mock.On call
//  - ctx context.Context
//  - token string
func (_e *MockSessionRepo_Expecter) CheckSessionExist(ctx interface{}, token interface{}) *MockSessionRepo_CheckSessionExist_Call {
	return &MockSessionRepo_CheckSessionExist_Call{Call: _e.mock.On("CheckSessionExist", ctx, token)}
}

func (_c *MockSessionRepo_CheckSessionExist_Call) Run(run func(ctx context.Context, token string)) *MockSessionRepo_CheckSessionExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSessionRepo_CheckSessionExist_Call) Return(_a0 bool, _a1 error) *MockSessionRepo_CheckSessionExist_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CheckTokenExist provides a mock function with given fields: ctx, memberId
func (_m *MockSessionRepo) CheckTokenExist(ctx context.Context, memberId string) (bool, error) {
	ret := _m.Called(ctx, memberId)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, memberId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, memberId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSessionRepo_CheckTokenExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckTokenExist'
type MockSessionRepo_CheckTokenExist_Call struct {
	*mock.Call
}

// CheckTokenExist is a helper method to define mock.On call
//  - ctx context.Context
//  - memberId string
func (_e *MockSessionRepo_Expecter) CheckTokenExist(ctx interface{}, memberId interface{}) *MockSessionRepo_CheckTokenExist_Call {
	return &MockSessionRepo_CheckTokenExist_Call{Call: _e.mock.On("CheckTokenExist", ctx, memberId)}
}

func (_c *MockSessionRepo_CheckTokenExist_Call) Run(run func(ctx context.Context, memberId string)) *MockSessionRepo_CheckTokenExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSessionRepo_CheckTokenExist_Call) Return(_a0 bool, _a1 error) *MockSessionRepo_CheckTokenExist_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetSessionByToken provides a mock function with given fields: ctx, token
func (_m *MockSessionRepo) GetSessionByToken(ctx context.Context, token string) (*po.MemberSession, error) {
	ret := _m.Called(ctx, token)

	var r0 *po.MemberSession
	if rf, ok := ret.Get(0).(func(context.Context, string) *po.MemberSession); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*po.MemberSession)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSessionRepo_GetSessionByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByToken'
type MockSessionRepo_GetSessionByToken_Call struct {
	*mock.Call
}

// GetSessionByToken is a helper method to define mock.On call
//  - ctx context.Context
//  - token string
func (_e *MockSessionRepo_Expecter) GetSessionByToken(ctx interface{}, token interface{}) *MockSessionRepo_GetSessionByToken_Call {
	return &MockSessionRepo_GetSessionByToken_Call{Call: _e.mock.On("GetSessionByToken", ctx, token)}
}

func (_c *MockSessionRepo_GetSessionByToken_Call) Run(run func(ctx context.Context, token string)) *MockSessionRepo_GetSessionByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSessionRepo_GetSessionByToken_Call) Return(_a0 *po.MemberSession, _a1 error) *MockSessionRepo_GetSessionByToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetTokenById provides a mock function with given fields: ctx, memberId
func (_m *MockSessionRepo) GetTokenById(ctx context.Context, memberId string) (string, error) {
	ret := _m.Called(ctx, memberId)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, memberId)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, memberId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSessionRepo_GetTokenById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenById'
type MockSessionRepo_GetTokenById_Call struct {
	*mock.Call
}

// GetTokenById is a helper method to define mock.On call
//  - ctx context.Context
//  - memberId string
func (_e *MockSessionRepo_Expecter) GetTokenById(ctx interface{}, memberId interface{}) *MockSessionRepo_GetTokenById_Call {
	return &MockSessionRepo_GetTokenById_Call{Call: _e.mock.On("GetTokenById", ctx, memberId)}
}

func (_c *MockSessionRepo_GetTokenById_Call) Run(run func(ctx context.Context, memberId string)) *MockSessionRepo_GetTokenById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSessionRepo_GetTokenById_Call) Return(_a0 string, _a1 error) *MockSessionRepo_GetTokenById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// RemoveUserLogin provides a mock function with given fields: ctx, token
func (_m *MockSessionRepo) RemoveUserLogin(ctx context.Context, token string) error {
	ret := _m.Called(ctx, token)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSessionRepo_RemoveUserLogin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveUserLogin'
type MockSessionRepo_RemoveUserLogin_Call struct {
	*mock.Call
}

// RemoveUserLogin is a helper method to define mock.On call
//  - ctx context.Context
//  - token string
func (_e *MockSessionRepo_Expecter) RemoveUserLogin(ctx interface{}, token interface{}) *MockSessionRepo_RemoveUserLogin_Call {
	return &MockSessionRepo_RemoveUserLogin_Call{Call: _e.mock.On("RemoveUserLogin", ctx, token)}
}

func (_c *MockSessionRepo_RemoveUserLogin_Call) Run(run func(ctx context.Context, token string)) *MockSessionRepo_RemoveUserLogin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSessionRepo_RemoveUserLogin_Call) Return(_a0 error) *MockSessionRepo_RemoveUserLogin_Call {
	_c.Call.Return(_a0)
	return _c
}

// SetMemberLogin provides a mock function with given fields: ctx, session
func (_m *MockSessionRepo) SetMemberLogin(ctx context.Context, session *po.MemberSession) error {
	ret := _m.Called(ctx, session)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *po.MemberSession) error); ok {
		r0 = rf(ctx, session)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSessionRepo_SetMemberLogin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMemberLogin'
type MockSessionRepo_SetMemberLogin_Call struct {
	*mock.Call
}

// SetMemberLogin is a helper method to define mock.On call
//  - ctx context.Context
//  - session *po.MemberSession
func (_e *MockSessionRepo_Expecter) SetMemberLogin(ctx interface{}, session interface{}) *MockSessionRepo_SetMemberLogin_Call {
	return &MockSessionRepo_SetMemberLogin_Call{Call: _e.mock.On("SetMemberLogin", ctx, session)}
}

func (_c *MockSessionRepo_SetMemberLogin_Call) Run(run func(ctx context.Context, session *po.MemberSession)) *MockSessionRepo_SetMemberLogin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*po.MemberSession))
	})
	return _c
}

func (_c *MockSessionRepo_SetMemberLogin_Call) Return(_a0 error) *MockSessionRepo_SetMemberLogin_Call {
	_c.Call.Return(_a0)
	return _c
}

// NewMockSessionRepo creates a new instance of MockSessionRepo. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockSessionRepo(t testing.TB) *MockSessionRepo {
	mock := &MockSessionRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
